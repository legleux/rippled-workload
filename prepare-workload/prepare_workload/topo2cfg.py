import argparse, json, os
from typing import Any, Iterable, Mapping

def normalize_edge(e: Any) -> tuple[str, str]:
    if isinstance(e, list):
        if len(e) == 2:
            return str(e[0]), str(e[1])
        if len(e) == 3 and isinstance(e[2], dict):
            return str(e[0]), str(e[1])
    if isinstance(e, dict):
        if "source" in e and "target" in e:
            return str(e["source"]), str(e["target"])
        if "u" in e and "v" in e:
            return str(e["u"]), str(e["v"])
    raise ValueError(f"Unrecognized edge format: {e!r}")

def collect_nodes(spec: Mapping[str, Any], out: list[str]) -> None:
    for n in (spec.get("nodes") or []):
        if isinstance(n, str):
            out.add(n)
        elif isinstance(n, Mapping) and "id" in n:
            out.add(str(n["id"]))
    for sg in (spec.get("subgraphs") or []):
        if isinstance(sg, Mapping):
            collect_nodes(sg, out)

def collect_edges(spec: Mapping[str, Any], out: list[tuple[str, str]]) -> None:
    for e in (spec.get("edges") or []):
        u, v = normalize_edge(e)
        out.append((u, v))
    for sg in (spec.get("subgraphs") or []):
        if isinstance(sg, Mapping):
            collect_edges(sg, out)


def get_peers(spec: Mapping[str, Any]) -> dict[str, list[str]]:
    # nodes: list[str] = []
    # collect_nodes(spec, nodes)
    nodes: list[str] = []
    edges: list[tuple[str, str]] = []
    # collect_edges(spec, edges)
    edges = spec
    # Include nodes that only appear in edges
    for u, v in edges:
        nodes.append(u);
        nodes.append(v)
    nodes = sorted(list(set(nodes)))
    pass
    adj: dict[str, list[str]] = {n: [] for n in nodes}
    for u, v in edges:
        adj.setdefault(u, [])
        adj.setdefault(v, [])
        # Peers always treated as symmetric.
        # We could change this so peers can have trouble communicating one way or the other.
        # Would need to make directed.
        adj[u].append(v);
        adj[v].append(u)
    # a node must not list itself
    for n in list(adj.keys()):
        # log.warn removing self reference!
        if n in adj[n]:
            adj[n].remove(n)
    return adj

def write_cfg(node: str, peers: Iterable[str], outdir: str) -> None:
    os.makedirs(outdir, exist_ok=True)
    path = os.path.join(outdir, f"{node}.cfg")
    with open(path, "w", encoding="utf-8") as f:
        f.write("# Autogenerated from topology JSON\n")
        f.write("[ips_fixed]\n")
        for p in sorted(peers):
            f.write(f"{p}\n")

def main():
    ap = argparse.ArgumentParser(
        description="Generate minimal rippled.cfg files with [ips_fixed] per node from a topology JSON."
    )
    ap.add_argument("topology_json", help="Path to the topology JSON file.")
    ap.add_argument("-o", "--outdir", default="cfg", help="Directory to write node cfg files (default: cfg)")
    ap.add_argument("--directed", action="store_true",
                    help="Treat edges as directed (default is undirected/symmetric peering).")
    ap.add_argument("--only-prefix", default=None,
                    help="Optional: only emit cfgs for nodes whose name starts with this prefix (e.g. 'val').")
    args = ap.parse_args()

    with open(args.topology_json, "r", encoding="utf-8") as f:
        spec = json.load(f)

    adj = build_adjacency(spec)

    count = 0
    for node, peers in adj.items():
        if args.only_prefix and not node.startswith(args.only_prefix):
            continue
        write_cfg(node, peers, args.outdir)
        count += 1

    print(f"Wrote {count} cfg files to {args.outdir}/")

if __name__ == "__main__":
    main()
